\chapter{tough-\/cookie}
\hypertarget{md_node__modules_2tough-cookie_2README}{}\label{md_node__modules_2tough-cookie_2README}\index{tough-\/cookie@{tough-\/cookie}}
\label{md_node__modules_2tough-cookie_2README_autotoc_md28397}%
\Hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28397}%
 \href{https://tools.ietf.org/html/rfc6265}{\texttt{ RFC 6265}} Cookies and Cookie\+Jar for Node.\+js

\href{https://nodei.co/npm/tough-cookie/}{\texttt{ }}

\href{https://travis-ci.org/salesforce/tough-cookie}{\texttt{ }}\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28398}{}\doxysection{\texorpdfstring{Synopsis}{Synopsis}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28398}

\begin{DoxyCode}{0}
\DoxyCodeLine{var\ tough\ =\ require("{}tough-\/cookie"{});}
\DoxyCodeLine{var\ Cookie\ =\ tough.Cookie;}
\DoxyCodeLine{var\ cookie\ =\ Cookie.parse(header);}
\DoxyCodeLine{cookie.value\ =\ "{}somethingdifferent"{};}
\DoxyCodeLine{header\ =\ cookie.toString();}
\DoxyCodeLine{var\ cookiejar\ =\ new\ tough.CookieJar();}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Asynchronous!}
\DoxyCodeLine{var\ cookie\ =\ await\ cookiejar.setCookie(}
\DoxyCodeLine{\ \ cookie,}
\DoxyCodeLine{\ \ "{}https://currentdomain.example.com/path"{}}
\DoxyCodeLine{);}
\DoxyCodeLine{var\ cookies\ =\ await\ cookiejar.getCookies("{}https://example.com/otherpath"{});}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Or\ with\ callbacks!}
\DoxyCodeLine{cookiejar.setCookie(}
\DoxyCodeLine{\ \ cookie,}
\DoxyCodeLine{\ \ "{}https://currentdomain.example.com/path"{},}
\DoxyCodeLine{\ \ function\ (err,\ cookie)\ \{}
\DoxyCodeLine{\ \ \ \ /*\ ...\ */}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{);}
\DoxyCodeLine{cookiejar.getCookies("{}http://example.com/otherpath"{},\ function\ (err,\ cookies)\ \{}
\DoxyCodeLine{\ \ /*\ ...\ */}
\DoxyCodeLine{\});}

\end{DoxyCode}


Why the name? NPM modules {\ttfamily cookie}, {\ttfamily cookies} and {\ttfamily cookiejar} were already taken.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28399}{}\doxysection{\texorpdfstring{Installation}{Installation}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28399}
It\textquotesingle{}s {\itshape so} easy! Install with {\ttfamily npm} or your preferred package manager.


\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ install\ tough-\/cookie}

\end{DoxyCode}
\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28400}{}\doxysection{\texorpdfstring{Node.\+js Version Support}{Node.js Version Support}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28400}
We follow the \href{https://github.com/nodejs/Release\#release-schedule}{\texttt{ node.\+js release schedule}} and support all versions that are in Active LTS or Maintenance. We will always do a major release when dropping support for older versions of node, and we will do so in consultation with our community.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28401}{}\doxysection{\texorpdfstring{API}{API}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28401}
\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28402}{}\doxysubsection{\texorpdfstring{tough}{tough}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28402}
The top-\/level exports from `require(\textquotesingle{}tough-\/cookie')\`{} can all be used as pure functions and don\textquotesingle{}t need to be bound.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28403}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$parse\+Date(string)$<$/tt$>$}{<tt>parseDate(string)</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28403}
Parse a cookie date string into a {\ttfamily Date}. Parses according to \href{https://datatracker.ietf.org/doc/html/rfc6265\#section-5.1.1}{\texttt{ RFC 6265 Section 5.\+1.\+1}}, not {\ttfamily Date.\+parse()}.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28404}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$format\+Date(date)$<$/tt$>$}{<tt>formatDate(date)</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28404}
Format a {\ttfamily Date} into an \href{https://datatracker.ietf.org/doc/html/rfc822\#section-5}{\texttt{ RFC 822}} string (the RFC 6265 recommended format).\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28405}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$canonical\+Domain(str)$<$/tt$>$}{<tt>canonicalDomain(str)</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28405}
Transforms a domain name into a canonical domain name. The canonical domain name is a domain name that has been trimmed, lowercased, stripped of leading dot, and optionally punycode-\/encoded (\href{https://datatracker.ietf.org/doc/html/rfc6265\#section-5.1.2}{\texttt{ Section 5.\+1.\+2 of RFC 6265}}). For the most part, this function is idempotent (calling the function with the output from a previous call returns the same output).\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28406}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$domain\+Match(str, dom\+Str\mbox{[}, canonicalize=true\mbox{]})$<$/tt$>$}{<tt>domainMatch(str, domStr[, canonicalize=true])</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28406}
Answers "{}does this real domain match the domain in a cookie?"{}. The {\ttfamily str} is the "{}current"{} domain name and the {\ttfamily dom\+Str} is the "{}cookie"{} domain name. Matches according to \href{https://datatracker.ietf.org/doc/html/rfc6265\#section-5.1.3}{\texttt{ RFC 6265 Section 5.\+1.\+3}}, but it helps to think of it as a "{}suffix match"{}.

The {\ttfamily canonicalize} parameter toggles whether the domain parameters get normalized with {\ttfamily canonical\+Domain} or not.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28407}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$default\+Path(path)$<$/tt$>$}{<tt>defaultPath(path)</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28407}
Given a current request/response path, gives the path appropriate for storing in a cookie. This is basically the "{}directory"{} of a "{}file"{} in the path, but is specified by \href{https://datatracker.ietf.org/doc/html/rfc6265\#section-5.1.4}{\texttt{ Section 5.\+1.\+4 of the RFC}}.

The {\ttfamily path} parameter MUST be {\itshape only} the pathname part of a URI (excluding the hostname, query, fragment, and so on). This is the {\ttfamily .pathname} property of node\textquotesingle{}s {\ttfamily uri.\+parse()} output.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28408}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$path\+Match(req\+Path, cookie\+Path)$<$/tt$>$}{<tt>pathMatch(reqPath, cookiePath)</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28408}
Answers "{}does the request-\/path path-\/match a given cookie-\/path?"{} as per \href{https://datatracker.ietf.org/doc/html/rfc6265\#section-5.1.4}{\texttt{ RFC 6265 Section 5.\+1.\+4}}. Returns a boolean.

This is essentially a prefix-\/match where {\ttfamily cookie\+Path} is a prefix of {\ttfamily req\+Path}.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28409}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$parse(cookie\+String\mbox{[}, options\mbox{]})$<$/tt$>$}{<tt>parse(cookieString[, options])</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28409}
Alias for \`{}\+Cookie.parse(cookie\+String\mbox{[}, options\mbox{]})\`{}.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28410}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$from\+JSON(string)$<$/tt$>$}{<tt>fromJSON(string)</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28410}
Alias for \`{}\+Cookie.from\+JSON(string)\`{}.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28411}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$get\+Public\+Suffix(hostname)$<$/tt$>$}{<tt>getPublicSuffix(hostname)</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28411}
Returns the public suffix of this hostname. The public suffix is the shortest domain name upon which a cookie can be set. Returns {\ttfamily null} if the hostname cannot have cookies set for it.

For example\+: {\ttfamily www.\+example.\+com} and {\ttfamily www.\+subdomain.\+example.\+com} both have public suffix {\ttfamily example.\+com}.

For further information, see the \href{http://publicsuffix.org/}{\texttt{ Public Suffix List}}. This module derives its list from that site. This call is a wrapper around \href{https://www.npmjs.com/package/psl}{\texttt{ {\ttfamily psl}}}\textquotesingle{}s \href{https://www.npmjs.com/package/psl\#\#pslgetdomain}{\texttt{ {\ttfamily get} method}}.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28412}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$cookie\+Compare(a, b)$<$/tt$>$}{<tt>cookieCompare(a, b)</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28412}
For use with {\ttfamily .sort()}, sorts a list of cookies into the recommended order given in step 2 of (\href{https://datatracker.ietf.org/doc/html/rfc6265\#section-5.4}{\texttt{ RFC 6265 Section 5.\+4}}). The sort algorithm is, in order of precedence\+:


\begin{DoxyItemize}
\item Longest {\ttfamily .path}
\item oldest {\ttfamily .creation} (which has a 1-\/ms precision, same as {\ttfamily Date})
\item lowest {\ttfamily .creation\+Index} (to get beyond the 1-\/ms precision)
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ cookies\ =\ [}
\DoxyCodeLine{\ \ /*\ unsorted\ array\ of\ Cookie\ objects\ */}
\DoxyCodeLine{];}
\DoxyCodeLine{cookies\ =\ cookies.sort(cookieCompare);}

\end{DoxyCode}


\begin{quote}
{\bfseries{Note}}\+: Since the Java\+Script {\ttfamily Date} is limited to a 1-\/ms precision, cookies within the same millisecond are entirely possible. This is especially true when using the {\ttfamily now} option to {\ttfamily .set\+Cookie()}. The {\ttfamily .creation\+Index} property is a per-\/process global counter, assigned during construction with {\ttfamily new Cookie()}, which preserves the spirit of the RFC sorting\+: older cookies go first. This works great for {\ttfamily Memory\+Cookie\+Store} since {\ttfamily Set-\/\+Cookie} headers are parsed in order, but is not so great for distributed systems. Sophisticated {\ttfamily Store}s may wish to set this to some other {\itshape logical clock} so that if cookies A and B are created in the same millisecond, but cookie A is created before cookie B, then {\ttfamily A.\+creation\+Index \texorpdfstring{$<$}{<} B.\+creation\+Index}. If you want to alter the global counter, which you probably {\itshape shouldn\textquotesingle{}t} do, it\textquotesingle{}s stored in {\ttfamily Cookie.\+cookies\+Created}. \end{quote}
\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28413}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$permute\+Domain(domain)$<$/tt$>$}{<tt>permuteDomain(domain)</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28413}
Generates a list of all possible domains that {\ttfamily domain\+Match()} the parameter. Can be handy for implementing cookie stores.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28414}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$permute\+Path(path)$<$/tt$>$}{<tt>permutePath(path)</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28414}
Generates a list of all possible paths that {\ttfamily path\+Match()} the parameter. Can be handy for implementing cookie stores.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28415}{}\doxysubsection{\texorpdfstring{Cookie}{Cookie}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28415}
Exported via {\ttfamily tough.\+Cookie}.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28416}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$\+Cookie.\+parse(cookie\+String\mbox{[}, options\mbox{]})$<$/tt$>$}{<tt>Cookie.parse(cookieString[, options])</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28416}
Parses a single Cookie or Set-\/\+Cookie HTTP header into a {\ttfamily Cookie} object. Returns {\ttfamily undefined} if the string can\textquotesingle{}t be parsed.

The options parameter is not required and currently has only one property\+:


\begin{DoxyItemize}
\item {\itshape loose} -\/ boolean -\/ if {\ttfamily true} enable parsing of keyless cookies like {\ttfamily =abc} and {\ttfamily =}, which are not RFC-\/compliant.
\end{DoxyItemize}

If options is not an object it is ignored, which means it can be used with \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map}{\texttt{ {\ttfamily Array\#map}}}.

To process the Set-\/\+Cookie header(s) on a node HTTP/\+HTTPS response\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{if\ (Array.isArray(res.headers["{}set-\/cookie"{}]))}
\DoxyCodeLine{\ \ cookies\ =\ res.headers["{}set-\/cookie"{}].map(Cookie.parse);}
\DoxyCodeLine{else\ cookies\ =\ [Cookie.parse(res.headers["{}set-\/cookie"{}])];}

\end{DoxyCode}


{\itshape Note\+:} In version 2.\+3.\+3, tough-\/cookie limited the number of spaces before the {\ttfamily =} to 256 characters. This limitation was removed in version 2.\+3.\+4. For more details, see \href{https://github.com/salesforce/tough-cookie/issues/92}{\texttt{ issue \#92}}.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28417}{}\doxysubsubsection{\texorpdfstring{Properties}{Properties}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28417}
Cookie object properties\+:


\begin{DoxyItemize}
\item {\itshape key} -\/ string -\/ the name or key of the cookie (default {\ttfamily "{}"{}})
\item {\itshape value} -\/ string -\/ the value of the cookie (default {\ttfamily "{}"{}})
\item {\itshape expires} -\/ {\ttfamily Date} -\/ if set, the {\ttfamily Expires=} attribute of the cookie (defaults to the string {\ttfamily "{}\+Infinity"{}}). See {\ttfamily set\+Expires()}
\item {\itshape max\+Age} -\/ seconds -\/ if set, the {\ttfamily Max-\/\+Age=} attribute {\itshape in seconds} of the cookie. Can also be set to strings {\ttfamily "{}\+Infinity"{}} and {\ttfamily "{}-\/\+Infinity"{}} for non-\/expiry and immediate-\/expiry, respectively. See {\ttfamily set\+Max\+Age()}
\item {\itshape domain} -\/ string -\/ the {\ttfamily Domain=} attribute of the cookie
\item {\itshape path} -\/ string -\/ the {\ttfamily Path=} of the cookie
\item {\itshape secure} -\/ boolean -\/ the {\ttfamily Secure} cookie flag
\item {\itshape http\+Only} -\/ boolean -\/ the {\ttfamily Http\+Only} cookie flag
\item {\itshape same\+Site} -\/ string -\/ the {\ttfamily Same\+Site} cookie attribute (from RFC 6265bis); must be one of {\ttfamily none}, {\ttfamily lax}, or {\ttfamily strict}
\item {\itshape extensions} -\/ {\ttfamily Array} -\/ any unrecognized cookie attributes as strings (even if equal-\/signs inside)
\item {\itshape creation} -\/ {\ttfamily Date} -\/ when this cookie was constructed
\item {\itshape creation\+Index} -\/ number -\/ set at construction, used to provide greater sort precision (see {\ttfamily cookie\+Compare(a,b)} for a full explanation)
\end{DoxyItemize}

After a cookie has been passed through {\ttfamily Cookie\+Jar.\+set\+Cookie()} it has the following additional attributes\+:


\begin{DoxyItemize}
\item {\itshape host\+Only} -\/ boolean -\/ is this a host-\/only cookie (that is, no Domain field was set, but was instead implied).
\item {\itshape path\+Is\+Default} -\/ boolean -\/ if true, there was no Path field on the cookie and {\ttfamily default\+Path()} was used to derive one.
\item {\itshape creation} -\/ {\ttfamily Date} -\/ {\bfseries{modified}} from construction to when the cookie was added to the jar.
\item {\itshape last\+Accessed} -\/ {\ttfamily Date} -\/ last time the cookie got accessed. Affects cookie cleaning after it is implemented. Using {\ttfamily cookiejar.\+get\+Cookies(...)} updates this attribute.
\end{DoxyItemize}\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28418}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$new Cookie(\mbox{[}properties\mbox{]})$<$/tt$>$}{<tt>new Cookie([properties])</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28418}
Receives an options object that can contain any of the above Cookie properties. Uses the default for unspecified properties.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28419}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+to\+String()$<$/tt$>$}{<tt>.toString()</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28419}
Encodes to a Set-\/\+Cookie header value. The Expires cookie field is set using {\ttfamily format\+Date()}, but is omitted entirely if {\ttfamily .expires} is {\ttfamily Infinity}.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28420}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+cookie\+String()$<$/tt$>$}{<tt>.cookieString()</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28420}
Encodes to a Cookie header value (specifically, the {\ttfamily .key} and {\ttfamily .value} properties joined with {\ttfamily "{}="{}}).\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28421}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+set\+Expires(string)$<$/tt$>$}{<tt>.setExpires(string)</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28421}
Sets the expiry based on a date-\/string passed through {\ttfamily parse\+Date()}. If parse\+Date returns {\ttfamily null} (that is, can\textquotesingle{}t parse this date string), {\ttfamily .expires} is set to {\ttfamily "{}\+Infinity"{}} (a string).\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28422}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+set\+Max\+Age(number)$<$/tt$>$}{<tt>.setMaxAge(number)</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28422}
Sets the max\+Age in seconds. Coerces {\ttfamily -\/Infinity} to {\ttfamily "{}-\/\+Infinity"{}} and {\ttfamily Infinity} to {\ttfamily "{}\+Infinity"{}} so it correctly serializes to JSON.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28423}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+expiry\+Date(\mbox{[}now=\+Date.\+now()\mbox{]})$<$/tt$>$}{<tt>.expiryDate([now=Date.now()])</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28423}
{\ttfamily expiry\+Time()} computes the absolute unix-\/epoch milliseconds that this cookie expires. {\ttfamily expiry\+Date()} works similarly, except it returns a {\ttfamily Date} object. Note that in both cases the {\ttfamily now} parameter should be milliseconds.

Max-\/\+Age takes precedence over Expires (as per the RFC). The {\ttfamily .creation} attribute -- or, by default, the {\ttfamily now} parameter -- is used to offset the {\ttfamily .max\+Age} attribute.

If Expires ({\ttfamily .expires}) is set, that\textquotesingle{}s returned.

Otherwise, {\ttfamily expiry\+Time()} returns {\ttfamily Infinity} and {\ttfamily expiry\+Date()} returns a {\ttfamily Date} object for "{}\+Tue, 19 Jan 2038 03\+:14\+:07 GMT"{} (latest date that can be expressed by a 32-\/bit {\ttfamily time\+\_\+t}; the common limit for most user-\/agents).\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28424}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+TTL(\mbox{[}now=\+Date.\+now()\mbox{]})$<$/tt$>$}{<tt>.TTL([now=Date.now()])</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28424}
Computes the TTL relative to {\ttfamily now} (milliseconds). The same precedence rules as for {\ttfamily expiry\+Time}/{\ttfamily expiry\+Date} apply.

{\ttfamily Infinity} is returned for cookies without an explicit expiry and {\ttfamily 0} is returned if the cookie is expired. Otherwise a time-\/to-\/live in milliseconds is returned.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28425}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+canonicalized\+Domain()$<$/tt$>$}{<tt>.canonicalizedDomain()</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28425}
\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28426}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+cdomain()$<$/tt$>$}{<tt>.cdomain()</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28426}
Returns the canonicalized {\ttfamily .domain} field. This is lower-\/cased and punycode (\href{https://datatracker.ietf.org/doc/html/rfc3490}{\texttt{ RFC 3490}}) encoded if the domain has any non-\/\+ASCII characters.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28427}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+to\+JSON()$<$/tt$>$}{<tt>.toJSON()</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28427}
For convenience in using {\ttfamily JSON.\+serialize(cookie)}. Returns a plain-\/old {\ttfamily Object} that can be JSON-\/serialized.

Any {\ttfamily Date} properties (such as {\ttfamily .expires}, {\ttfamily .creation}, and {\ttfamily .last\+Accessed}) are exported in ISO format ({\ttfamily .to\+ISOString()}).

\begin{quote}
{\bfseries{NOTE}}\+: Custom {\ttfamily Cookie} properties are discarded. In tough-\/cookie 1.\+x, since there was no {\ttfamily .to\+JSON} method explicitly defined, all enumerable properties were captured. If you want a property to be serialized, add the property name to the {\ttfamily Cookie.\+serializable\+Properties} Array. \end{quote}
\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28428}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$\+Cookie.\+from\+JSON(str\+Or\+Obj)$<$/tt$>$}{<tt>Cookie.fromJSON(strOrObj)</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28428}
Does the reverse of {\ttfamily cookie.\+to\+JSON()}. If passed a string, will {\ttfamily JSON.\+parse()} that first.

Any {\ttfamily Date} properties (such as {\ttfamily .expires}, {\ttfamily .creation}, and {\ttfamily .last\+Accessed}) are parsed via \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse}{\texttt{ {\ttfamily Date.\+parse}}}, not tough-\/cookie\textquotesingle{}s {\ttfamily parse\+Date}, since ISO timestamps are being handled at this layer.

Returns {\ttfamily null} upon a JSON parsing error.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28429}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+clone()$<$/tt$>$}{<tt>.clone()</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28429}
Does a deep clone of this cookie, implemented exactly as {\ttfamily Cookie.\+from\+JSON(cookie.\+to\+JSON())}.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28430}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+validate()$<$/tt$>$}{<tt>.validate()</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28430}
Status\+: {\itshape IN PROGRESS}. Works for a few things, but is by no means comprehensive.

Validates cookie attributes for semantic correctness. Useful for "{}lint"{} checking any Set-\/\+Cookie headers you generate. For now, it returns a boolean, but eventually could return a reason string. Future-\/proof with this construct\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{if\ (cookie.validate()\ ===\ true)\ \{}
\DoxyCodeLine{\ \ //\ it's\ tasty}
\DoxyCodeLine{\}\ else\ \{}
\DoxyCodeLine{\ \ //\ yuck!}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28431}{}\doxysubsection{\texorpdfstring{Cookie\+Jar}{CookieJar}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28431}
Exported via {\ttfamily tough.\+Cookie\+Jar}.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28432}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$\+Cookie\+Jar(\mbox{[}store\mbox{]}\mbox{[}, options\mbox{]})$<$/tt$>$}{<tt>CookieJar([store][, options])</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28432}
Simply use {\ttfamily new Cookie\+Jar()}. If a custom store is not passed to the constructor, a \`{}\+Memory\+Cookie\+Store\`{} is created and used.

The {\ttfamily options} object can be omitted and can have the following properties\+:


\begin{DoxyItemize}
\item {\itshape reject\+Public\+Suffixes} -\/ boolean -\/ default {\ttfamily true} -\/ reject cookies with domains like "{}com"{} and "{}co.\+uk"{}
\item {\itshape loose\+Mode} -\/ boolean -\/ default {\ttfamily false} -\/ accept malformed cookies like {\ttfamily bar} and {\ttfamily =bar}, which have an implied empty name.
\item {\itshape prefix\+Security} -\/ string -\/ default {\ttfamily silent} -\/ set to `\textquotesingle{}unsafe-\/disabled'{\ttfamily ,}\textquotesingle{}silent\textquotesingle{}{\ttfamily , or}\textquotesingle{}strict\textquotesingle{}{\ttfamily . See \mbox{[}Cookie Prefixes\mbox{]}(\#cookie-\/prefixes) below.}
\item {\ttfamily \+\_\+allow\+Special\+Use\+Domain\+\_\+ -\/ boolean -\/ default}true{\ttfamily -\/ accepts special-\/use domain suffixes, such as}local\`{}. Useful for testing purposes. This is not in the standard, but is used sometimes on the web and is accepted by most browsers.
\end{DoxyItemize}\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28433}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+set\+Cookie(cookie\+Or\+String, current\+Url\mbox{[}, options\mbox{]}\mbox{[}, callback(err, cookie)\mbox{]})$<$/tt$>$}{<tt>.setCookie(cookieOrString, currentUrl[, options][, callback(err, cookie)])</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28433}
Attempt to set the cookie in the cookie jar. The cookie has updated {\ttfamily .creation}, {\ttfamily .last\+Accessed} and {\ttfamily .host\+Only} properties. And returns a promise if a callback is not provided.

The {\ttfamily options} object can be omitted and can have the following properties\+:


\begin{DoxyItemize}
\item {\itshape http} -\/ boolean -\/ default {\ttfamily true} -\/ indicates if this is an HTTP or non-\/\+HTTP API. Affects {\ttfamily Http\+Only} cookies.
\item {\itshape secure} -\/ boolean -\/ autodetect from URL -\/ indicates if this is a "{}\+Secure"{} API. If the current\+Url starts with {\ttfamily https\+:} or {\ttfamily wss\+:} this defaults to {\ttfamily true}, otherwise {\ttfamily false}.
\item {\itshape now} -\/ Date -\/ default {\ttfamily new Date()} -\/ what to use for the creation or access time of cookies.
\item {\itshape ignore\+Error} -\/ boolean -\/ default {\ttfamily false} -\/ silently ignore things like parse errors and invalid domains. {\ttfamily Store} errors aren\textquotesingle{}t ignored by this option.
\item {\itshape same\+Site\+Context} -\/ string -\/ default unset -\/ set to `\textquotesingle{}none'{\ttfamily ,}\textquotesingle{}lax\textquotesingle{}{\ttfamily , or}\textquotesingle{}strict\textquotesingle{}\`{} See Same\+Site Cookies below.
\end{DoxyItemize}

As per the RFC, the {\ttfamily .host\+Only} property is set if there was no "{}\+Domain="{} parameter in the cookie string (or {\ttfamily .domain} was null on the Cookie object). The {\ttfamily .domain} property is set to the fully-\/qualified hostname of {\ttfamily current\+Url} in this case. Matching this cookie requires an exact hostname match (not a {\ttfamily domain\+Match} as per usual).\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28434}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+set\+Cookie\+Sync(cookie\+Or\+String, current\+Url\mbox{[}, options\mbox{]})$<$/tt$>$}{<tt>.setCookieSync(cookieOrString, currentUrl[, options])</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28434}
Synchronous version of \`{}set\+Cookie\`{}; only works with synchronous stores (that is, the default {\ttfamily Memory\+Cookie\+Store}).\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28435}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+get\+Cookies(current\+Url\mbox{[}, options\mbox{]}\mbox{[}, callback(err, cookies)\mbox{]})$<$/tt$>$}{<tt>.getCookies(currentUrl[, options][, callback(err, cookies)])</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28435}
Retrieve the list of cookies that can be sent in a Cookie header for the current URL. Returns a promise if a callback is not provided.

Returns an array of {\ttfamily Cookie} objects, sorted by default using \`{}cookie\+Compare\`{}.

If an error is encountered it\textquotesingle{}s passed as {\ttfamily err} to the callback, otherwise an array of {\ttfamily Cookie} objects is passed. The array is sorted with {\ttfamily cookie\+Compare()} unless the {\ttfamily \{sort\+:false\}} option is given.

The {\ttfamily options} object can be omitted and can have the following properties\+:


\begin{DoxyItemize}
\item {\itshape http} -\/ boolean -\/ default {\ttfamily true} -\/ indicates if this is an HTTP or non-\/\+HTTP API. Affects {\ttfamily Http\+Only} cookies.
\item {\itshape secure} -\/ boolean -\/ autodetect from URL -\/ indicates if this is a "{}\+Secure"{} API. If the current\+Url starts with {\ttfamily https\+:} or {\ttfamily wss\+:} then this is defaulted to {\ttfamily true}, otherwise {\ttfamily false}.
\item {\itshape now} -\/ Date -\/ default {\ttfamily new Date()} -\/ what to use for the creation or access time of cookies
\item {\itshape expire} -\/ boolean -\/ default {\ttfamily true} -\/ perform expiry-\/time checking of cookies and asynchronously remove expired cookies from the store. Using {\ttfamily false} returns expired cookies and does {\bfseries{not}} remove them from the store (which is potentially useful for replaying Set-\/\+Cookie headers).
\item {\itshape all\+Paths} -\/ boolean -\/ default {\ttfamily false} -\/ if {\ttfamily true}, do not scope cookies by path. The default uses RFC-\/compliant path scoping. {\bfseries{Note}}\+: may not be supported by the underlying store (the default {\ttfamily Memory\+Cookie\+Store} supports it).
\item {\itshape same\+Site\+Context} -\/ string -\/ default unset -\/ Set this to `\textquotesingle{}none'{\ttfamily ,}\textquotesingle{}lax\textquotesingle{}{\ttfamily , or}\textquotesingle{}strict\textquotesingle{}\`{} to enforce Same\+Site cookies upon retrieval. See Same\+Site Cookies below.
\item {\itshape sort} -\/ boolean -\/ whether to sort the list of cookies.
\end{DoxyItemize}

The {\ttfamily .last\+Accessed} property of the returned cookies will have been updated.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28436}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+get\+Cookies\+Sync(current\+Url, \mbox{[}\{options\}\mbox{]})$<$/tt$>$}{<tt>.getCookiesSync(currentUrl, [\{options\}])</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28436}
Synchronous version of \`{}get\+Cookies\`{}; only works with synchronous stores (for example, the default {\ttfamily Memory\+Cookie\+Store}).\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28437}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+get\+Cookie\+String(...)$<$/tt$>$}{<tt>.getCookieString(...)</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28437}
Accepts the same options as \`{}.get\+Cookies()\`{} but returns a string suitable for a Cookie header rather than an Array.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28438}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+get\+Cookie\+String\+Sync(...)$<$/tt$>$}{<tt>.getCookieStringSync(...)</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28438}
Synchronous version of \`{}get\+Cookie\+String\`{}; only works with synchronous stores (for example, the default {\ttfamily Memory\+Cookie\+Store}).\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28439}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+get\+Set\+Cookie\+Strings(...)$<$/tt$>$}{<tt>.getSetCookieStrings(...)</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28439}
Returns an array of strings suitable for {\bfseries{Set-\/\+Cookie}} headers. Accepts the same options as \`{}.get\+Cookies()\`{}. Simply maps the cookie array via {\ttfamily .to\+String()}.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28440}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+get\+Set\+Cookie\+Strings\+Sync(...)$<$/tt$>$}{<tt>.getSetCookieStringsSync(...)</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28440}
Synchronous version of \`{}get\+Set\+Cookie\+Strings\`{}; only works with synchronous stores (for example, the default {\ttfamily Memory\+Cookie\+Store}).\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28441}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+serialize(\mbox{[}callback(err, serialized\+Object)\mbox{]})$<$/tt$>$}{<tt>.serialize([callback(err, serializedObject)])</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28441}
Returns a promise if a callback is not provided.

Serialize the Jar if the underlying store supports {\ttfamily .get\+All\+Cookies}.

\begin{quote}
{\bfseries{NOTE}}\+: Custom {\ttfamily Cookie} properties are discarded. If you want a property to be serialized, add the property name to the {\ttfamily Cookie.\+serializable\+Properties} Array. \end{quote}
See Serialization Format.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28442}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+serialize\+Sync()$<$/tt$>$}{<tt>.serializeSync()</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28442}
Synchronous version of \`{}serialize\`{}; only works with synchronous stores (for example, the default {\ttfamily Memory\+Cookie\+Store}).\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28443}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+to\+JSON()$<$/tt$>$}{<tt>.toJSON()</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28443}
Alias of \`{}.serialize\+Sync()\`{} for the convenience of {\ttfamily JSON.\+stringify(cookiejar)}.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28444}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$\+Cookie\+Jar.\+deserialize(serialized\mbox{[}, store\mbox{]}\mbox{[}, callback(err, object)\mbox{]})$<$/tt$>$}{<tt>CookieJar.deserialize(serialized[, store][, callback(err, object)])</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28444}
A new Jar is created and the serialized Cookies are added to the underlying store. Each {\ttfamily Cookie} is added via {\ttfamily store.\+put\+Cookie} in the order in which they appear in the serialization. A promise is returned if a callback is not provided.

The {\ttfamily store} argument is optional, but should be an instance of {\ttfamily Store}. By default, a new instance of {\ttfamily Memory\+Cookie\+Store} is created.

As a convenience, if {\ttfamily serialized} is a string, it is passed through {\ttfamily JSON.\+parse} first.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28445}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$\+Cookie\+Jar.\+deserialize\+Sync(serialized\mbox{[}, store\mbox{]})$<$/tt$>$}{<tt>CookieJar.deserializeSync(serialized[, store])</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28445}
Sync version of \`{}.deserialize\`{}; only works with synchronous stores (for example, the default {\ttfamily Memory\+Cookie\+Store}).\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28446}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$\+Cookie\+Jar.\+from\+JSON(string)$<$/tt$>$}{<tt>CookieJar.fromJSON(string)</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28446}
Alias of \`{}.deserialize\+Sync\`{} to provide consistency with \`{}\+Cookie.from\+JSON()\`{}.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28447}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+clone(\mbox{[}store\mbox{]}\mbox{[}, callback(err, cloned))$<$/tt$>$}{<tt>.clone([store][, callback(err, cloned))</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28447}
Produces a deep clone of this jar. Modifications to the original do not affect the clone, and vice versa. Returns a promise if a callback is not provided.

The {\ttfamily store} argument is optional, but should be an instance of {\ttfamily Store}. By default, a new instance of {\ttfamily Memory\+Cookie\+Store} is created. Transferring between store types is supported so long as the source implements {\ttfamily .get\+All\+Cookies()} and the destination implements {\ttfamily .put\+Cookie()}.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28448}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+clone\+Sync(\mbox{[}store\mbox{]})$<$/tt$>$}{<tt>.cloneSync([store])</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28448}
Synchronous version of \`{}.clone\`{}, returning a new {\ttfamily Cookie\+Jar} instance.

The {\ttfamily store} argument is optional, but must be a {\itshape synchronous} {\ttfamily Store} instance if specified. If not passed, a new instance of {\ttfamily Memory\+Cookie\+Store} is used.

The {\itshape source} and {\itshape destination} must both be synchronous {\ttfamily Store}s. If one or both stores are asynchronous, use {\ttfamily .clone} instead. Recall that {\ttfamily Memory\+Cookie\+Store} supports both synchronous and asynchronous API calls.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28449}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+remove\+All\+Cookies(\mbox{[}callback(err)\mbox{]})$<$/tt$>$}{<tt>.removeAllCookies([callback(err)])</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28449}
Removes all cookies from the jar. Returns a promise if a callback is not provided.

This is a new backwards-\/compatible feature of {\ttfamily tough-\/cookie} version 2.\+5, so not all Stores will implement it efficiently. For Stores that do not implement {\ttfamily remove\+All\+Cookies}, the fallback is to call {\ttfamily remove\+Cookie} after {\ttfamily get\+All\+Cookies}. If {\ttfamily get\+All\+Cookies} fails or isn\textquotesingle{}t implemented in the Store, that error is returned. If one or more of the {\ttfamily remove\+Cookie} calls fail, only the first error is returned.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28450}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$.\+remove\+All\+Cookies\+Sync()$<$/tt$>$}{<tt>.removeAllCookiesSync()</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28450}
Sync version of \`{}.remove\+All\+Cookies()\`{}; only works with synchronous stores (for example, the default {\ttfamily Memory\+Cookie\+Store}).\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28451}{}\doxysubsection{\texorpdfstring{Store}{Store}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28451}
Base class for Cookie\+Jar stores. Available as {\ttfamily tough.\+Store}.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28452}{}\doxysubsection{\texorpdfstring{Store API}{Store API}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28452}
The storage model for each {\ttfamily Cookie\+Jar} instance can be replaced with a custom implementation. The default is {\ttfamily Memory\+Cookie\+Store} which can be found in \href{https://github.com/salesforce/tough-cookie/blob/master/lib/memstore.js}{\texttt{ {\ttfamily lib/memstore.\+js}}}. The API uses continuation-\/passing-\/style to allow for asynchronous stores.

Stores should inherit from the base {\ttfamily Store} class, which is available as a top-\/level export.

Stores are asynchronous by default, but if {\ttfamily store.\+synchronous} is set to {\ttfamily true}, then the {\ttfamily \texorpdfstring{$\ast$}{*}\+Sync} methods of the containing {\ttfamily Cookie\+Jar} can be used.

All {\ttfamily domain} parameters are normalized before calling.

The Cookie store must have all of the following methods. Note that asynchronous implementations {\bfseries{must}} support callback parameters.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28453}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$store.\+find\+Cookie(domain, path, key, callback(err, cookie))$<$/tt$>$}{<tt>store.findCookie(domain, path, key, callback(err, cookie))</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28453}
Retrieve a cookie with the given domain, path, and key (name). The RFC maintains that exactly one of these cookies should exist in a store. If the store is using versioning, this means that the latest or newest such cookie should be returned.

Callback takes an error and the resulting {\ttfamily Cookie} object. If no cookie is found then {\ttfamily null} MUST be passed instead (that is, not an error).\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28454}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$store.\+find\+Cookies(domain, path, allow\+Special\+Use\+Domain, callback(err, cookies))$<$/tt$>$}{<tt>store.findCookies(domain, path, allowSpecialUseDomain, callback(err, cookies))</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28454}
Locates cookies matching the given domain and path. This is most often called in the context of \`{}cookiejar.get\+Cookies()\`{}.

If no cookies are found, the callback MUST be passed an empty array.

The resulting list is checked for applicability to the current request according to the RFC (domain-\/match, path-\/match, http-\/only-\/flag, secure-\/flag, expiry, and so on), so it\textquotesingle{}s OK to use an optimistic search algorithm when implementing this method. However, the search algorithm used SHOULD try to find cookies that {\ttfamily domain\+Match()} the domain and {\ttfamily path\+Match()} the path in order to limit the amount of checking that needs to be done.

As of version 0.\+9.\+12, the {\ttfamily all\+Paths} option to {\ttfamily cookiejar.\+get\+Cookies()} above causes the path here to be {\ttfamily null}. If the path is {\ttfamily null}, path-\/matching MUST NOT be performed (that is, domain-\/matching only).\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28455}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$store.\+put\+Cookie(cookie, callback(err))$<$/tt$>$}{<tt>store.putCookie(cookie, callback(err))</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28455}
Adds a new cookie to the store. The implementation SHOULD replace any existing cookie with the same {\ttfamily .domain}, {\ttfamily .path}, and {\ttfamily .key} properties. Depending on the nature of the implementation, it\textquotesingle{}s possible that between the call to {\ttfamily fetch\+Cookie} and {\ttfamily put\+Cookie} that a duplicate {\ttfamily put\+Cookie} can occur.

The {\ttfamily cookie} object MUST NOT be modified; as the caller has already updated the {\ttfamily .creation} and {\ttfamily .last\+Accessed} properties.

Pass an error if the cookie cannot be stored.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28456}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$store.\+update\+Cookie(old\+Cookie, new\+Cookie, callback(err))$<$/tt$>$}{<tt>store.updateCookie(oldCookie, newCookie, callback(err))</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28456}
Update an existing cookie. The implementation MUST update the {\ttfamily .value} for a cookie with the same {\ttfamily domain}, {\ttfamily .path}, and {\ttfamily .key}. The implementation SHOULD check that the old value in the store is equivalent to {\ttfamily old\+Cookie} -\/ how the conflict is resolved is up to the store.

The {\ttfamily .last\+Accessed} property is always different between the two objects (to the precision possible via Java\+Script\textquotesingle{}s clock). Both {\ttfamily .creation} and {\ttfamily .creation\+Index} are guaranteed to be the same. Stores MAY ignore or defer the {\ttfamily .last\+Accessed} change at the cost of affecting how cookies are selected for automatic deletion (for example, least-\/recently-\/used, which is up to the store to implement).

Stores may wish to optimize changing the {\ttfamily .value} of the cookie in the store versus storing a new cookie. If the implementation doesn\textquotesingle{}t define this method, a stub that calls \`{}put\+Cookie\`{} is added to the store object.

The {\ttfamily new\+Cookie} and {\ttfamily old\+Cookie} objects MUST NOT be modified.

Pass an error if the new\+Cookie cannot be stored.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28457}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$store.\+remove\+Cookie(domain, path, key, callback(err))$<$/tt$>$}{<tt>store.removeCookie(domain, path, key, callback(err))</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28457}
Remove a cookie from the store (see notes on \`{}find\+Cookie\`{} about the uniqueness constraint).

The implementation MUST NOT pass an error if the cookie doesn\textquotesingle{}t exist, and only pass an error due to the failure to remove an existing cookie.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28458}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$store.\+remove\+Cookies(domain, path, callback(err))$<$/tt$>$}{<tt>store.removeCookies(domain, path, callback(err))</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28458}
Removes matching cookies from the store. The {\ttfamily path} parameter is optional and if missing, means all paths in a domain should be removed.

Pass an error ONLY if removing any existing cookies failed.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28459}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$store.\+remove\+All\+Cookies(callback(err))$<$/tt$>$}{<tt>store.removeAllCookies(callback(err))</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28459}
{\itshape Optional}. Removes all cookies from the store.

Pass an error if one or more cookies can\textquotesingle{}t be removed.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28460}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$store.\+get\+All\+Cookies(callback(err, cookies))$<$/tt$>$}{<tt>store.getAllCookies(callback(err, cookies))</tt>}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28460}
{\itshape Optional}. Produces an {\ttfamily Array} of all cookies during \`{}jar.serialize()\`{}. The items in the array can be true {\ttfamily Cookie} objects or generic {\ttfamily Object}s with the Serialization Format data structure.

Cookies SHOULD be returned in creation order to preserve sorting via \`{}compare\+Cookie()\`{}. For reference, {\ttfamily Memory\+Cookie\+Store} sorts by {\ttfamily .creation\+Index} since it uses true {\ttfamily Cookie} objects internally. If you don\textquotesingle{}t return the cookies in creation order, they\textquotesingle{}ll still be sorted by creation time, but this only has a precision of 1-\/ms. See {\ttfamily cookie\+Compare} for more detail.

Pass an error if retrieval fails.

{\bfseries{Note}}\+: Not all Stores can implement this due to technical limitations, so it is optional.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28461}{}\doxysubsection{\texorpdfstring{Memory\+Cookie\+Store}{MemoryCookieStore}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28461}
Inherits from {\ttfamily Store}.

A just-\/in-\/memory Cookie\+Jar synchronous store implementation, used by default. Despite being a synchronous implementation, it\textquotesingle{}s usable with both the synchronous and asynchronous forms of the {\ttfamily Cookie\+Jar} API. Supports serialization, {\ttfamily get\+All\+Cookies}, and {\ttfamily remove\+All\+Cookies}.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28462}{}\doxysubsection{\texorpdfstring{Community Cookie Stores}{Community Cookie Stores}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28462}
These are some Store implementations authored and maintained by the community. They aren\textquotesingle{}t official and we don\textquotesingle{}t vouch for them but you may be interested to have a look\+:


\begin{DoxyItemize}
\item \href{https://github.com/JSBizon/db-cookie-store}{\texttt{ {\ttfamily db-\/cookie-\/store}}}\+: SQL including SQLite-\/based databases
\item \href{https://github.com/JSBizon/file-cookie-store}{\texttt{ {\ttfamily file-\/cookie-\/store}}}\+: Netscape cookie file format on disk
\item \href{https://github.com/benkroeger/redis-cookie-store}{\texttt{ {\ttfamily redis-\/cookie-\/store}}}\+: Redis
\item \href{https://github.com/mitsuru/tough-cookie-filestore}{\texttt{ {\ttfamily tough-\/cookie-\/filestore}}}\+: JSON on disk
\item \href{https://github.com/exponentjs/tough-cookie-web-storage-store}{\texttt{ {\ttfamily tough-\/cookie-\/web-\/storage-\/store}}}\+: DOM local\+Storage and session\+Storage
\end{DoxyItemize}\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28463}{}\doxysection{\texorpdfstring{Serialization Format}{Serialization Format}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28463}
{\bfseries{NOTE}}\+: If you want to have custom {\ttfamily Cookie} properties serialized, add the property name to {\ttfamily Cookie.\+serializable\+Properties}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ //\ The\ version\ of\ tough-\/cookie\ that\ serialized\ this\ jar.}
\DoxyCodeLine{\ \ version:\ 'tough-\/cookie@1.x.y',}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ add\ the\ store\ type,\ to\ make\ humans\ happy:}
\DoxyCodeLine{\ \ storeType:\ 'MemoryCookieStore',}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ CookieJar\ configuration:}
\DoxyCodeLine{\ \ rejectPublicSuffixes:\ true,}
\DoxyCodeLine{\ \ //\ ...\ future\ items\ go\ here}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ Gets\ filled\ from\ jar.store.getAllCookies():}
\DoxyCodeLine{\ \ cookies:\ [}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ key:\ 'string',}
\DoxyCodeLine{\ \ \ \ \ \ value:\ 'string',}
\DoxyCodeLine{\ \ \ \ \ \ //\ ...}
\DoxyCodeLine{\ \ \ \ \ \ /*\ other\ Cookie.serializableProperties\ go\ here\ */}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ ]}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28464}{}\doxysection{\texorpdfstring{RFC 6265bis}{RFC 6265bis}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28464}
Support for RFC 6265bis revision 02 is being developed. Since this is a bit of an omnibus revision to the RFC 6252, support is broken up into the functional areas.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28465}{}\doxysubsection{\texorpdfstring{Leave Secure Cookies Alone}{Leave Secure Cookies Alone}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28465}
Not yet supported.

This change makes it so that if a cookie is sent from the server to the client with a {\ttfamily Secure} attribute, the channel must also be secure or the cookie is ignored.\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28466}{}\doxysubsection{\texorpdfstring{Same\+Site Cookies}{SameSite Cookies}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28466}
Supported.

This change makes it possible for servers, and supporting clients, to mitigate certain types of CSRF attacks by disallowing {\ttfamily Same\+Site} cookies from being sent cross-\/origin.

On the Cookie object itself, you can get or set the {\ttfamily .same\+Site} attribute, which is serialized into the {\ttfamily Same\+Site=} cookie attribute. When unset or {\ttfamily undefined}, no {\ttfamily Same\+Site=} attribute is serialized. The valid values of this attribute are `\textquotesingle{}none'{\ttfamily ,}\textquotesingle{}lax\textquotesingle{}{\ttfamily , or}\textquotesingle{}strict\textquotesingle{}\`{}. Other values are serialized as-\/is.

When parsing cookies with a {\ttfamily Same\+Site} cookie attribute, values other than `\textquotesingle{}lax'{\ttfamily or}\textquotesingle{}strict\textquotesingle{}{\ttfamily are parsed as}\textquotesingle{}none\textquotesingle{}{\ttfamily . For example,}Some\+Cookie=Some\+Value; Same\+Site=garbage{\ttfamily parses so that}cookie.\+same\+Site === \textquotesingle{}none\textquotesingle{}\`{}.

In order to support Same\+Site cookies, you must provide a {\ttfamily same\+Site\+Context} option to {\itshape both} {\ttfamily set\+Cookie} and {\ttfamily get\+Cookies}. Valid values for this option are just like for the Cookie object, but have particular meanings\+:


\begin{DoxyEnumerate}
\item `\textquotesingle{}strict'{\ttfamily mode -\/ If the request is on the same "{}site for cookies"{} (see the RFC draft for more information), pass this option to add a layer of defense against CSRF. 2.}\textquotesingle{}lax\textquotesingle{}{\ttfamily mode -\/ If the request is from another site, \+\_\+but\+\_\+ is directly because of navigation by the user, such as,}$<$link type=prefetch$>$$>${\ttfamily or}\href{...}{\texttt{ {\ttfamily , pass}same\+Site\+Context\+: \textquotesingle{}lax\textquotesingle{}{\ttfamily . 3.}\textquotesingle{}none\textquotesingle{}{\ttfamily -\/ Otherwise, pass}same\+Site\+Context\+: \textquotesingle{}none\textquotesingle{}{\ttfamily (this indicates a cross-\/origin request)..unset/}undefined\`{} -\/ Same\+Site {\bfseries{is not}} be enforced! This can be a valid use-\/case for when CSRF isn\textquotesingle{}t in the threat model of the system being built. It is highly recommended that you read RFC 6265bis for fine details on Same\+Site cookies. In particular Section 8.\+8}} discusses security considerations and defense in depth.
\end{DoxyEnumerate}\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28467}{}\doxysubsection{\texorpdfstring{Cookie Prefixes}{Cookie Prefixes}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28467}
Supported.

Cookie prefixes are a way to indicate that a given cookie was set with a set of attributes simply by inspecting the first few characters of the cookie\textquotesingle{}s name.

Cookie prefixes are defined in \href{https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03\#\#section-4.1.3}{\texttt{ Section 4.\+1.\+3 of 6265bis}}.

Two prefixes are defined\+:


\begin{DoxyEnumerate}
\item {\ttfamily "{}\+\_\+\+\_\+\+Secure-\/"{} Prefix}\+: If a cookie\textquotesingle{}s name begins with a case-\/sensitive match for the string "{}\textbackslash{}\+\_\+\textbackslash{}\+\_\+\+Secure-\/"{}, then the cookie was set with a "{}\+Secure"{} attribute.
\item {\ttfamily "{}\+\_\+\+\_\+\+Host-\/"{} Prefix}\+: If a cookie\textquotesingle{}s name begins with a case-\/sensitive match for the string "{}\textbackslash{}\+\_\+\textbackslash{}\+\_\+\+Host-\/"{}, then the cookie was set with a "{}\+Secure"{} attribute, a "{}\+Path"{} attribute with a value of "{}/"{}, and no "{}\+Domain"{} attribute.
\end{DoxyEnumerate}

If {\ttfamily prefix\+Security} is enabled for {\ttfamily Cookie\+Jar}, then cookies that match the prefixes defined above but do not obey the attribute restrictions are not added.

You can define this functionality by passing in the {\ttfamily prefix\+Security} option to {\ttfamily Cookie\+Jar}. It can be one of 3 values\+:


\begin{DoxyEnumerate}
\item {\ttfamily silent}\+: Enable cookie prefix checking but silently fail to add the cookie if conditions are not met. Default.
\item {\ttfamily strict}\+: Enable cookie prefix checking and error out if conditions are not met.
\item {\ttfamily unsafe-\/disabled}\+: Disable cookie prefix checking.
\end{DoxyEnumerate}

Note that if {\ttfamily ignore\+Error} is passed in as {\ttfamily true} then the error is silent regardless of the {\ttfamily prefix\+Security} option (assuming it\textquotesingle{}s enabled).\hypertarget{md_node__modules_2tough-cookie_2README_autotoc_md28468}{}\doxysection{\texorpdfstring{Copyright and License}{Copyright and License}}\label{md_node__modules_2tough-cookie_2README_autotoc_md28468}
BSD-\/3-\/\+Clause\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Copyright\ (c)\ 2015,\ Salesforce.com,\ Inc.}
\DoxyCodeLine{All\ rights\ reserved.}
\DoxyCodeLine{}
\DoxyCodeLine{Redistribution\ and\ use\ in\ source\ and\ binary\ forms,\ with\ or\ without}
\DoxyCodeLine{modification,\ are\ permitted\ provided\ that\ the\ following\ conditions\ are\ met:}
\DoxyCodeLine{}
\DoxyCodeLine{1.\ Redistributions\ of\ source\ code\ must\ retain\ the\ above\ copyright\ notice,}
\DoxyCodeLine{this\ list\ of\ conditions\ and\ the\ following\ disclaimer.}
\DoxyCodeLine{}
\DoxyCodeLine{2.\ Redistributions\ in\ binary\ form\ must\ reproduce\ the\ above\ copyright\ notice,}
\DoxyCodeLine{this\ list\ of\ conditions\ and\ the\ following\ disclaimer\ in\ the\ documentation}
\DoxyCodeLine{and/or\ other\ materials\ provided\ with\ the\ distribution.}
\DoxyCodeLine{}
\DoxyCodeLine{3.\ Neither\ the\ name\ of\ Salesforce.com\ nor\ the\ names\ of\ its\ contributors\ may}
\DoxyCodeLine{be\ used\ to\ endorse\ or\ promote\ products\ derived\ from\ this\ software\ without}
\DoxyCodeLine{specific\ prior\ written\ permission.}
\DoxyCodeLine{}
\DoxyCodeLine{THIS\ SOFTWARE\ IS\ PROVIDED\ BY\ THE\ COPYRIGHT\ HOLDERS\ AND\ CONTRIBUTORS\ "{}AS\ IS"{}}
\DoxyCodeLine{AND\ ANY\ EXPRESS\ OR\ IMPLIED\ WARRANTIES,\ INCLUDING,\ BUT\ NOT\ LIMITED\ TO,\ THE}
\DoxyCodeLine{IMPLIED\ WARRANTIES\ OF\ MERCHANTABILITY\ AND\ FITNESS\ FOR\ A\ PARTICULAR\ PURPOSE}
\DoxyCodeLine{ARE\ DISCLAIMED.\ IN\ NO\ EVENT\ SHALL\ THE\ COPYRIGHT\ HOLDER\ OR\ CONTRIBUTORS\ BE}
\DoxyCodeLine{LIABLE\ FOR\ ANY\ DIRECT,\ INDIRECT,\ INCIDENTAL,\ SPECIAL,\ EXEMPLARY,\ OR}
\DoxyCodeLine{CONSEQUENTIAL\ DAMAGES\ (INCLUDING,\ BUT\ NOT\ LIMITED\ TO,\ PROCUREMENT\ OF}
\DoxyCodeLine{SUBSTITUTE\ GOODS\ OR\ SERVICES;\ LOSS\ OF\ USE,\ DATA,\ OR\ PROFITS;\ OR\ BUSINESS}
\DoxyCodeLine{INTERRUPTION)\ HOWEVER\ CAUSED\ AND\ ON\ ANY\ THEORY\ OF\ LIABILITY,\ WHETHER\ IN}
\DoxyCodeLine{CONTRACT,\ STRICT\ LIABILITY,\ OR\ TORT\ (INCLUDING\ NEGLIGENCE\ OR\ OTHERWISE)}
\DoxyCodeLine{ARISING\ IN\ ANY\ WAY\ OUT\ OF\ THE\ USE\ OF\ THIS\ SOFTWARE,\ EVEN\ IF\ ADVISED\ OF\ THE}
\DoxyCodeLine{POSSIBILITY\ OF\ SUCH\ DAMAGE.}

\end{DoxyCode}
 