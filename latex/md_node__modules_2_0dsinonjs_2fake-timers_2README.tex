\chapter{\texorpdfstring{$<$}{<}tt\texorpdfstring{$>$}{>}\textbackslash{}@sinonjs/fake-\/timers\texorpdfstring{$<$}{<}/tt\texorpdfstring{$>$}{>}}
\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README}{}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README}\index{$<$tt$>$\textbackslash{}"@sinonjs/fake-\/timers$<$/tt$>$@{$<$tt$>$\textbackslash{}"@sinonjs/fake-\/timers$<$/tt$>$}}
\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2501}%
\Hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2501}%
 \href{https://circleci.com/gh/sinonjs/fake-timers}{\texttt{ }} \href{https://codecov.io/gh/sinonjs/fake-timers}{\texttt{ }} \href{CODE_OF_CONDUCT.md}{\texttt{ }}

Java\+Script implementation of the timer APIs; {\ttfamily set\+Timeout}, {\ttfamily clear\+Timeout}, {\ttfamily set\+Immediate}, {\ttfamily clear\+Immediate}, {\ttfamily set\+Interval}, {\ttfamily clear\+Interval}, {\ttfamily request\+Animation\+Frame}, {\ttfamily cancel\+Animation\+Frame}, {\ttfamily request\+Idle\+Callback}, and {\ttfamily cancel\+Idle\+Callback}, along with a clock instance that controls the flow of time. Fake\+Timers also provides a {\ttfamily Date} implementation that gets its time from the clock.

In addition in browser environment {\ttfamily @sinonjs/fake-\/timers} provides a {\ttfamily performance} implementation that gets its time from the clock. In Node environments Fake\+Timers provides a {\ttfamily next\+Tick} implementation that is synchronized with the clock -\/ and a {\ttfamily process.\+hrtime} shim that works with the clock.

{\ttfamily @sinonjs/fake-\/timers} can be used to simulate passing time in automated tests and other situations where you want the scheduling semantics, but don\textquotesingle{}t want to actually wait.

{\ttfamily @sinonjs/fake-\/timers} is extracted from \href{https://github.com/sinonjs/sinon.js}{\texttt{ Sinon.\+JS}} and targets the \href{https://sinonjs.org/releases/latest/\#supported-runtimes}{\texttt{ same runtimes}}.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2502}{}\doxysection{\texorpdfstring{Autocomplete, Intelli\+Sense and Type\+Script definitions}{Autocomplete, IntelliSense and TypeScript definitions}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2502}
Version 7 introduced JSDoc to the codebase. This should provide autocomplete and type suggestions in supporting IDEs. If you need more elaborate type support, Type\+Script definitions for the Sinon projects are independently maintained by the Definitely Types community\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ install\ -\/D\ @types/sinonjs\_\_fake-\/timers}

\end{DoxyCode}
\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2503}{}\doxysection{\texorpdfstring{Installation}{Installation}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2503}
{\ttfamily @sinonjs/fake-\/timers} can be used in both Node and browser environments. Installation is as easy as


\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ install\ @sinonjs/fake-\/timers}

\end{DoxyCode}


If you want to use {\ttfamily @sinonjs/fake-\/timers} in a browser you can either build your own bundle or use \href{https://www.skypack.dev}{\texttt{ Skypack}}.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2504}{}\doxysection{\texorpdfstring{Usage}{Usage}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2504}
To use {\ttfamily @sinonjs/fake-\/timers}, create a new clock, schedule events on it using the timer functions and pass time using the {\ttfamily tick} method.


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ In\ the\ browser\ distribution,\ a\ global\ \`{}FakeTimers`\ is\ already\ available}
\DoxyCodeLine{var\ FakeTimers\ =\ require("{}@sinonjs/fake-\/timers"{});}
\DoxyCodeLine{var\ clock\ =\ FakeTimers.createClock();}
\DoxyCodeLine{}
\DoxyCodeLine{clock.setTimeout(function\ ()\ \{}
\DoxyCodeLine{\ \ \ \ console.log(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}The\ poblano\ is\ a\ mild\ chili\ pepper\ originating\ in\ the\ state\ of\ Puebla,\ Mexico."{}}
\DoxyCodeLine{\ \ \ \ );}
\DoxyCodeLine{\},\ 15);}
\DoxyCodeLine{}
\DoxyCodeLine{//\ ...}
\DoxyCodeLine{}
\DoxyCodeLine{clock.tick(15);}

\end{DoxyCode}


Upon executing the last line, an interesting fact about the \href{https://en.wikipedia.org/wiki/Poblano}{\texttt{ Poblano}} will be printed synchronously to the screen. If you want to simulate asynchronous behavior, you have to use your imagination when calling the various functions.

The {\ttfamily next}, {\ttfamily run\+All}, {\ttfamily run\+To\+Frame}, and {\ttfamily run\+To\+Last} methods are available to advance the clock. See the API Reference for more details.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2505}{}\doxysubsection{\texorpdfstring{Faking the native timers}{Faking the native timers}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2505}
When using {\ttfamily @sinonjs/fake-\/timers} to test timers, you will most likely want to replace the native timers such that calling {\ttfamily set\+Timeout} actually schedules a callback with your clock instance, not the browser\textquotesingle{}s internals.

Calling {\ttfamily install} with no arguments achieves this. You can call {\ttfamily uninstall} later to restore things as they were again.


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ In\ the\ browser\ distribution,\ a\ global\ \`{}FakeTimers`\ is\ already\ available}
\DoxyCodeLine{var\ FakeTimers\ =\ require("{}@sinonjs/fake-\/timers"{});}
\DoxyCodeLine{}
\DoxyCodeLine{var\ clock\ =\ FakeTimers.install();}
\DoxyCodeLine{//\ Equivalent\ to}
\DoxyCodeLine{//\ var\ clock\ =\ FakeTimers.install(typeof\ global\ !==\ "{}undefined"{}\ ?\ global\ :\ window);}
\DoxyCodeLine{}
\DoxyCodeLine{setTimeout(fn,\ 15);\ //\ Schedules\ with\ clock.setTimeout}
\DoxyCodeLine{}
\DoxyCodeLine{clock.uninstall();}
\DoxyCodeLine{//\ setTimeout\ is\ restored\ to\ the\ native\ implementation}

\end{DoxyCode}


To hijack timers in another context pass it to the {\ttfamily install} method.


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ FakeTimers\ =\ require("{}@sinonjs/fake-\/timers"{});}
\DoxyCodeLine{var\ context\ =\ \{}
\DoxyCodeLine{\ \ \ \ setTimeout:\ setTimeout,\ //\ By\ default\ context.setTimeout\ uses\ the\ global\ setTimeout}
\DoxyCodeLine{\};}
\DoxyCodeLine{var\ clock\ =\ FakeTimers.withGlobal(context).install();}
\DoxyCodeLine{}
\DoxyCodeLine{context.setTimeout(fn,\ 15);\ //\ Schedules\ with\ clock.setTimeout}
\DoxyCodeLine{}
\DoxyCodeLine{clock.uninstall();}
\DoxyCodeLine{//\ context.setTimeout\ is\ restored\ to\ the\ original\ implementation}

\end{DoxyCode}


Usually you want to install the timers onto the global object, so call {\ttfamily install} without arguments.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2506}{}\doxysubsubsection{\texorpdfstring{Automatically incrementing mocked time}{Automatically incrementing mocked time}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2506}
Fake\+Timers supports the possibility to attach the faked timers to any change in the real system time. This means that there is no need to {\ttfamily tick()} the clock in a situation where you won\textquotesingle{}t know {\bfseries{when}} to call {\ttfamily tick()}.

Please note that this is achieved using the original set\+Immediate() API at a certain configurable interval {\ttfamily config.\+advance\+Time\+Delta} (default\+: 20ms). Meaning time would be incremented every 20ms, not in real time.

An example would be\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ FakeTimers\ =\ require("{}@sinonjs/fake-\/timers"{});}
\DoxyCodeLine{var\ clock\ =\ FakeTimers.install(\{}
\DoxyCodeLine{\ \ \ \ shouldAdvanceTime:\ true,}
\DoxyCodeLine{\ \ \ \ advanceTimeDelta:\ 40,}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{setTimeout(()\ =>\ \{}
\DoxyCodeLine{\ \ \ \ console.log("{}this\ just\ timed\ out"{});\ //executed\ after\ 40ms}
\DoxyCodeLine{\},\ 30);}
\DoxyCodeLine{}
\DoxyCodeLine{setImmediate(()\ =>\ \{}
\DoxyCodeLine{\ \ \ \ console.log("{}not\ so\ immediate"{});\ //executed\ after\ 40ms}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{setTimeout(()\ =>\ \{}
\DoxyCodeLine{\ \ \ \ console.log("{}this\ timed\ out\ after"{});\ //executed\ after\ 80ms}
\DoxyCodeLine{\ \ \ \ clock.uninstall();}
\DoxyCodeLine{\},\ 50);}

\end{DoxyCode}
\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2507}{}\doxysection{\texorpdfstring{API Reference}{API Reference}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2507}
\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2508}{}\doxysubsection{\texorpdfstring{$<$tt$>$var clock = Fake\+Timers.\+create\+Clock(\mbox{[}now\mbox{[}, loop\+Limit\mbox{]}\mbox{]})$<$/tt$>$}{<tt>var clock = FakeTimers.createClock([now[, loopLimit]])</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2508}
Creates a clock. The default \href{https://en.wikipedia.org/wiki/Epoch_\%28reference_date\%29}{\texttt{ epoch}} is {\ttfamily 0}.

The {\ttfamily now} argument may be a number (in milliseconds) or a Date object.

The {\ttfamily loop\+Limit} argument sets the maximum number of timers that will be run when calling {\ttfamily run\+All()} before assuming that we have an infinite loop and throwing an error. The default is {\ttfamily 1000}.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2509}{}\doxysubsection{\texorpdfstring{$<$tt$>$var clock = Fake\+Timers.\+install(\mbox{[}config\mbox{]})$<$/tt$>$}{<tt>var clock = FakeTimers.install([config])</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2509}
Installs Fake\+Timers using the specified config (otherwise with epoch {\ttfamily 0} on the global scope). The following configuration options are available

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Parameter   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Default   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Parameter   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Default   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-4}
\endhead
{\ttfamily config.\+now}   &Number/\+Date   &0   &installs Fake\+Timers with the specified unix epoch    \\\cline{1-4}
{\ttfamily config.\+to\+Fake}   &String\mbox{[}\mbox{]}   &\mbox{[}"{}set\+Timeout"{}, "{}clear\+Timeout"{}, "{}set\+Immediate"{}, "{}clear\+Immediate"{},"{}set\+Interval"{}, "{}clear\+Interval"{}, "{}\+Date"{}, "{}request\+Animation\+Frame"{}, "{}cancel\+Animation\+Frame"{}, "{}request\+Idle\+Callback"{}, "{}cancel\+Idle\+Callback"{}, "{}hrtime"{}\mbox{]}   &an array with explicit function names to hijack. {\itshape When not set, Fake\+Timers will automatically fake all methods {\bfseries{except}} {\ttfamily next\+Tick}} e.\+g., {\ttfamily Fake\+Timers.\+install(\{ to\+Fake\+: \mbox{[}"{}set\+Timeout"{},"{}next\+Tick"{}\mbox{]}\})} will fake only {\ttfamily set\+Timeout} and {\ttfamily next\+Tick}    \\\cline{1-4}
{\ttfamily config.\+loop\+Limit}   &Number   &1000   &the maximum number of timers that will be run when calling run\+All()    \\\cline{1-4}
{\ttfamily config.\+should\+Advance\+Time}   &Boolean   &false   &tells Fake\+Timers to increment mocked time automatically based on the real system time shift (e.\+g. the mocked time will be incremented by 20ms for every 20ms change in the real system time)    \\\cline{1-4}
{\ttfamily config.\+advance\+Time\+Delta}   &Number   &20   &relevant only when using with {\ttfamily should\+Advance\+Time\+: true}. increment mocked time by {\ttfamily advance\+Time\+Delta} ms every {\ttfamily advance\+Time\+Delta} ms change in the real system time.    \\\cline{1-4}
{\ttfamily config.\+should\+Clear\+Native\+Timers}   &Boolean   &false   &tells Fake\+Timers to clear \textquotesingle{}native\textquotesingle{} (i.\+e. not fake) timers by delegating to their respective handlers. These are not cleared by default, leading to potentially unexpected behavior if timers existed prior to installing Fake\+Timers.   \\\cline{1-4}
\end{longtabu}
\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2510}{}\doxysubsection{\texorpdfstring{$<$tt$>$var id = clock.\+set\+Timeout(callback, timeout)$<$/tt$>$}{<tt>var id = clock.setTimeout(callback, timeout)</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2510}
Schedules the callback to be fired once {\ttfamily timeout} milliseconds have ticked by.

In Node.\+js {\ttfamily set\+Timeout} returns a timer object. Fake\+Timers will do the same, however its {\ttfamily ref()} and {\ttfamily unref()} methods have no effect.

In browsers a timer ID is returned.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2511}{}\doxysubsection{\texorpdfstring{$<$tt$>$clock.\+clear\+Timeout(id)$<$/tt$>$}{<tt>clock.clearTimeout(id)</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2511}
Clears the timer given the ID or timer object, as long as it was created using {\ttfamily set\+Timeout}.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2512}{}\doxysubsection{\texorpdfstring{$<$tt$>$var id = clock.\+set\+Interval(callback, timeout)$<$/tt$>$}{<tt>var id = clock.setInterval(callback, timeout)</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2512}
Schedules the callback to be fired every time {\ttfamily timeout} milliseconds have ticked by.

In Node.\+js {\ttfamily set\+Interval} returns a timer object. Fake\+Timers will do the same, however its {\ttfamily ref()} and {\ttfamily unref()} methods have no effect.

In browsers a timer ID is returned.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2513}{}\doxysubsection{\texorpdfstring{$<$tt$>$clock.\+clear\+Interval(id)$<$/tt$>$}{<tt>clock.clearInterval(id)</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2513}
Clears the timer given the ID or timer object, as long as it was created using {\ttfamily set\+Interval}.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2514}{}\doxysubsection{\texorpdfstring{$<$tt$>$var id = clock.\+set\+Immediate(callback)$<$/tt$>$}{<tt>var id = clock.setImmediate(callback)</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2514}
Schedules the callback to be fired once {\ttfamily 0} milliseconds have ticked by. Note that you\textquotesingle{}ll still have to call {\ttfamily clock.\+tick()} for the callback to fire. If called during a tick the callback won\textquotesingle{}t fire until {\ttfamily 1} millisecond has ticked by.

In Node.\+js {\ttfamily set\+Immediate} returns a timer object. Fake\+Timers will do the same, however its {\ttfamily ref()} and {\ttfamily unref()} methods have no effect.

In browsers a timer ID is returned.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2515}{}\doxysubsection{\texorpdfstring{$<$tt$>$clock.\+clear\+Immediate(id)$<$/tt$>$}{<tt>clock.clearImmediate(id)</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2515}
Clears the timer given the ID or timer object, as long as it was created using {\ttfamily set\+Immediate}.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2516}{}\doxysubsection{\texorpdfstring{$<$tt$>$clock.\+request\+Animation\+Frame(callback)$<$/tt$>$}{<tt>clock.requestAnimationFrame(callback)</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2516}
Schedules the callback to be fired on the next animation frame, which runs every 16 ticks. Returns an {\ttfamily id} which can be used to cancel the callback. This is available in both browser \& node environments.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2517}{}\doxysubsection{\texorpdfstring{$<$tt$>$clock.\+cancel\+Animation\+Frame(id)$<$/tt$>$}{<tt>clock.cancelAnimationFrame(id)</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2517}
Cancels the callback scheduled by the provided id.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2518}{}\doxysubsection{\texorpdfstring{$<$tt$>$clock.\+request\+Idle\+Callback(callback\mbox{[}, timeout\mbox{]})$<$/tt$>$}{<tt>clock.requestIdleCallback(callback[, timeout])</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2518}
Queued the callback to be fired during idle periods to perform background and low priority work on the main event loop. Callbacks which have a timeout option will be fired no later than time in milliseconds. Returns an {\ttfamily id} which can be used to cancel the callback.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2519}{}\doxysubsection{\texorpdfstring{$<$tt$>$clock.\+cancel\+Idle\+Callback(id)$<$/tt$>$}{<tt>clock.cancelIdleCallback(id)</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2519}
Cancels the callback scheduled by the provided id.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2520}{}\doxysubsection{\texorpdfstring{$<$tt$>$clock.\+count\+Timers()$<$/tt$>$}{<tt>clock.countTimers()</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2520}
Returns the number of waiting timers. This can be used to assert that a test finishes without leaking any timers.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2521}{}\doxysubsection{\texorpdfstring{$<$tt$>$clock.\+hrtime(prev\+Time?)$<$/tt$>$}{<tt>clock.hrtime(prevTime?)</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2521}
Only available in Node.\+js, mimicks process.\+hrtime().\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2522}{}\doxysubsection{\texorpdfstring{$<$tt$>$clock.\+next\+Tick(callback)$<$/tt$>$}{<tt>clock.nextTick(callback)</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2522}
Only available in Node.\+js, mimics {\ttfamily process.\+next\+Tick} to enable completely synchronous testing flows.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2523}{}\doxysubsection{\texorpdfstring{$<$tt$>$clock.\+performance.\+now()$<$/tt$>$}{<tt>clock.performance.now()</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2523}
Only available in browser environments, mimicks performance.\+now().\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2524}{}\doxysubsection{\texorpdfstring{$<$tt$>$clock.\+tick(time)$<$/tt$>$ / $<$tt$>$await clock.\+tick\+Async(time)$<$/tt$>$}{<tt>clock.tick(time)</tt> / <tt>await clock.tickAsync(time)</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2524}
Advance the clock, firing callbacks if necessary. {\ttfamily time} may be the number of milliseconds to advance the clock by or a human-\/readable string. Valid string formats are {\ttfamily "{}08"{}} for eight seconds, {\ttfamily "{}01\+:00"{}} for one minute and {\ttfamily "{}02\+:34\+:10"{}} for two hours, 34 minutes and ten seconds.

The {\ttfamily tick\+Async()} will also break the event loop, allowing any scheduled promise callbacks to execute {\itshape before} running the timers.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2525}{}\doxysubsection{\texorpdfstring{$<$tt$>$clock.\+next()$<$/tt$>$ / $<$tt$>$await clock.\+next\+Async()$<$/tt$>$}{<tt>clock.next()</tt> / <tt>await clock.nextAsync()</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2525}
Advances the clock to the the moment of the first scheduled timer, firing it.

The {\ttfamily next\+Async()} will also break the event loop, allowing any scheduled promise callbacks to execute {\itshape before} running the timers.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2526}{}\doxysubsection{\texorpdfstring{$<$tt$>$clock.\+reset()$<$/tt$>$}{<tt>clock.reset()</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2526}
Removes all timers and ticks without firing them, and sets {\ttfamily now} to {\ttfamily config.\+now} that was provided to {\ttfamily Fake\+Timers.\+install} or to {\ttfamily 0} if {\ttfamily config.\+now} was not provided. Useful to reset the state of the clock without having to {\ttfamily uninstall} and {\ttfamily install} it.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2527}{}\doxysubsection{\texorpdfstring{$<$tt$>$clock.\+run\+All()$<$/tt$>$ / $<$tt$>$await clock.\+run\+All\+Async()$<$/tt$>$}{<tt>clock.runAll()</tt> / <tt>await clock.runAllAsync()</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2527}
This runs all pending timers until there are none remaining. If new timers are added while it is executing they will be run as well.

This makes it easier to run asynchronous tests to completion without worrying about the number of timers they use, or the delays in those timers.

It runs a maximum of {\ttfamily loop\+Limit} times after which it assumes there is an infinite loop of timers and throws an error.

The {\ttfamily run\+All\+Async()} will also break the event loop, allowing any scheduled promise callbacks to execute {\itshape before} running the timers.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2528}{}\doxysubsection{\texorpdfstring{$<$tt$>$clock.\+run\+Microtasks()$<$/tt$>$}{<tt>clock.runMicrotasks()</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2528}
This runs all pending microtasks scheduled with {\ttfamily next\+Tick} but none of the timers and is mostly useful for libraries using Fake\+Timers underneath and for running {\ttfamily next\+Tick} items without any timers.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2529}{}\doxysubsection{\texorpdfstring{$<$tt$>$clock.\+run\+To\+Frame()$<$/tt$>$}{<tt>clock.runToFrame()</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2529}
Advances the clock to the next frame, firing all scheduled animation frame callbacks, if any, for that frame as well as any other timers scheduled along the way.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2530}{}\doxysubsection{\texorpdfstring{$<$tt$>$clock.\+run\+To\+Last()$<$/tt$>$ / $<$tt$>$await clock.\+run\+To\+Last\+Async()$<$/tt$>$}{<tt>clock.runToLast()</tt> / <tt>await clock.runToLastAsync()</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2530}
This takes note of the last scheduled timer when it is run, and advances the clock to that time firing callbacks as necessary.

If new timers are added while it is executing they will be run only if they would occur before this time.

This is useful when you want to run a test to completion, but the test recursively sets timers that would cause {\ttfamily run\+All} to trigger an infinite loop warning.

The {\ttfamily run\+To\+Last\+Async()} will also break the event loop, allowing any scheduled promise callbacks to execute {\itshape before} running the timers.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2531}{}\doxysubsection{\texorpdfstring{$<$tt$>$clock.\+set\+System\+Time(\mbox{[}now\mbox{]})$<$/tt$>$}{<tt>clock.setSystemTime([now])</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2531}
This simulates a user changing the system clock while your program is running. It affects the current time but it does not in itself cause e.\+g. timers to fire; they will fire exactly as they would have done without the call to set\+System\+Time().\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2532}{}\doxysubsection{\texorpdfstring{$<$tt$>$clock.\+uninstall()$<$/tt$>$}{<tt>clock.uninstall()</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2532}
Restores the original methods of the native timers or the methods on the object that was passed to {\ttfamily Fake\+Timers.\+with\+Global}\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2533}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Date$<$/tt$>$}{<tt>Date</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2533}
Implements the {\ttfamily Date} object but using the clock to provide the correct time.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2534}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Performance$<$/tt$>$}{<tt>Performance</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2534}
Implements the {\ttfamily now} method of the \href{https://developer.mozilla.org/en-US/docs/Web/API/Performance/now}{\texttt{ {\ttfamily Performance}}} object but using the clock to provide the correct time. Only available in environments that support the Performance object (browsers mostly).\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2535}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Fake\+Timers.\+with\+Global$<$/tt$>$}{<tt>FakeTimers.withGlobal</tt>}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2535}
In order to support creating clocks based on separate or sandboxed environments (such as JSDOM), Fake\+Timers exports a factory method which takes single argument {\ttfamily global}, which it inspects to figure out what to mock and what features to support. When invoking this function with a global, you will get back an object with {\ttfamily timers}, {\ttfamily create\+Clock} and {\ttfamily install} -\/ same as the regular Fake\+Timers exports only based on the passed in global instead of the global environment.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2536}{}\doxysection{\texorpdfstring{Running tests}{Running tests}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2536}
Fake\+Timers has a comprehensive test suite. If you\textquotesingle{}re thinking of contributing bug fixes or suggesting new features, you need to make sure you have not broken any tests. You are also expected to add tests for any new behavior.\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2537}{}\doxysubsection{\texorpdfstring{On node\+:}{On node:}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2537}

\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ test}

\end{DoxyCode}


Or, if you prefer more verbose output\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\$(npm\ bin)/mocha\ ./test/fake-\/timers-\/test.js}

\end{DoxyCode}
\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2538}{}\doxysubsection{\texorpdfstring{In the browser}{In the browser}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2538}
\href{https://github.com/mantoni/mochify.js}{\texttt{ Mochify}} is used to run the tests in Phantom\+JS. Make sure you have {\ttfamily phantomjs} installed. Then\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ test-\/headless}

\end{DoxyCode}
\hypertarget{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2539}{}\doxysection{\texorpdfstring{License}{License}}\label{md_node__modules_2_0dsinonjs_2fake-timers_2README_autotoc_md2539}
BSD 3-\/clause "{}\+New"{} or "{}\+Revised"{} License (see LICENSE file) 